/*
 * generated by Xtext
 */
package avroclipse.validation

import avroclipse.avroIDL.AvroIDLFile
import avroclipse.avroIDL.AvroIDLPackage
import avroclipse.avroIDL.CustomTypeLink
import avroclipse.avroIDL.ProtocolElement
import avroclipse.avroIDL.Type
import com.google.inject.Inject
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.validation.Check

import static extension org.eclipse.xtext.EcoreUtil2.*

//import org.eclipse.xtext.validation.Check
/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AvroIDLValidator extends AbstractAvroIDLValidator {

	@Inject XtextResourceSet _rs;

	public static val DUPLICATED_NAME = 'duplicatedName'

	// static val SKIP_DUPLICATED_NAME_CHECK_CLASSES = newArrayList(Annotation)
	static val INCLUDE_EXTERNAL_DUPLICATE_NAME_CHECK_CLASSES = newArrayList(Type)

	public static val TYPE_DEFINED_AFTER_REFERENCE = "typeDefiendAfterReference"

	public static val INVALID_CHAR_IN_NAMESPACE = "invalidCharInNamespace"

	static val invalidNamespaceChars = newHashSet('-', '_', ' ')

	@Check
	def emptyStringNamespace(AvroIDLFile file) {
		if (file.name != null) {
			if (file.name.isEmpty) {
				error("Namespace must not be empty", AvroIDLPackage.Literals.AVRO_IDL_FILE__NAME)
			}
		}
	}

	@Check
	def checkNamespaceName(AvroIDLFile file) {
		if (!file.name.nullOrEmpty) {
			for (invalidNamespaceChar : invalidNamespaceChars) {
				if (file.name.contains(invalidNamespaceChar)) {
					error("Characters '-', '_' & ' ' are not allowed in namespace names",
						AvroIDLPackage.Literals.AVRO_IDL_FILE__NAME, INVALID_CHAR_IN_NAMESPACE)
					return;
				}
			}
		}
	}

	@Check
	def typeDefinedAfterReference(CustomTypeLink link) {
		val type = link.target
		if (type != null) {
			val idlFile = EcoreUtil2.getContainerOfType(type, AvroIDLFile)
			if (elementInSameFile(idlFile, link)) {
				val elements = idlFile.elements
				val linkContainerElement = EcoreUtil2.getContainerOfType(type, ProtocolElement)
				val ownContainerElement = EcoreUtil2.getContainerOfType(link, ProtocolElement)
				val linkElementIndex = elements.indexOf(linkContainerElement)
				val ownElementIndex = elements.indexOf(ownContainerElement)
				if (ownElementIndex < linkElementIndex) {
					error("Reference to type '" + link.target.name + "' is before type definition",
						AvroIDLPackage.Literals.CUSTOM_TYPE_LINK__TARGET, TYPE_DEFINED_AFTER_REFERENCE,
						ownElementIndex.toString, linkElementIndex.toString)
				}
			}

		}
	}

	def elementInSameFile(AvroIDLFile file, EObject eObject) {
		if (file != null) {
			val objectFile = EcoreUtil2.getContainerOfType(eObject, AvroIDLFile)
			return file == objectFile
		}
		return false
	}

	/* @Check
	 * def checkDuplicatedInnerCheck(EObject object) {
	 * 	if (SKIP_DUPLICATED_NAME_CHECK_CLASSES.findFirst[it.isInstance(object)] != null) {
	 * 		return; // skip
	 * 	}
	 * 
	 * 	val nameFeature = object.eClass.getEStructuralFeature("name")
	 * 
	 * 	if (object.eContainer != null && nameFeature != null) {
	 * 		if (isDuplicated(object, nameFeature)) {
	 * 			error(getDuplicateMessage(object, nameFeature), nameFeature, DUPLICATED_NAME)
	 * 		}
	 * 	}
	 }*/
	def getDuplicateMessage(EObject object, EStructuralFeature feature) {
		return "Duplicated " + object.eClass.superType.name + " '" + object.eGet(feature) + "'"
	}

	def isDuplicated(EObject object, EStructuralFeature nameFeature) {
		val name = object.eGet(nameFeature) as String;
		val internallyDuplicated = isInternallyDuplicated(object, nameFeature, name)
		if (!internallyDuplicated) {
			if (INCLUDE_EXTERNAL_DUPLICATE_NAME_CHECK_CLASSES.findFirst[it.isInstance(object)] != null) {
				return isExternallyDuplicated(object, nameFeature, name) // check for external import name duplications	
			}
		}
		return internallyDuplicated;
	}

	def isExternallyDuplicated(EObject object, EStructuralFeature nameFeature, String name) {
		val idlFile = object.getContainerOfType(AvroIDLFile);
		if (idlFile != null) {
			var Resource res
			var URI uri
			var AvroIDLFile IdlFile;

			for (import : idlFile.imports) {
				uri = URI.createURI(import.importURI)
				res = _rs.getResource(uri, true);
				if (object.isValidUri(uri)) {
					if (res != null && res.contents.size > 0) {
						IdlFile = res.contents.get(0) as AvroIDLFile
						if (IdlFile != null) {
							if (IdlFile.eAllContents.findFirst [
								it.eClass.superType == object.eClass.superType && it.eGet(nameFeature).equals(name)
							] != null) {
								return true;
							}
						}
					}
				}
			}
		}
		return false
	}

	def isInternallyDuplicated(EObject object, EStructuralFeature nameFeature, String name) {
		object.eContainer.eAllContents.findFirst [
			it.eClass.superType == object.eClass.superType && it.eGet(nameFeature).equals(name) && it != object
		] != null
	}

	public static def getSuperType(EClass eClass) {
		val superTypes = eClass.ESuperTypes
		if (superTypes.isEmpty) {
			return eClass
		} else {
			return superTypes.get(0)
		}
	}

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
