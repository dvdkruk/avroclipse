/*
 * generated by Xtext
 */
package avroclipse.validation

import avroclipse.avroIDL.AvroIDLFile
import avroclipse.avroIDL.AvroIDLPackage
import avroclipse.avroIDL.CustomTypeLink
import avroclipse.avroIDL.ProtocolElement
import avroclipse.avroIDL.Type
import com.google.inject.Inject
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.validation.Check

import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AvroIDLValidator extends AbstractAvroIDLValidator {

	@Inject XtextResourceSet _rs;

	public static val DUPLICATED_NAME = 'duplicatedName'

	static val INCLUDE_EXTERNAL_DUPLICATE_NAME_CHECK_CLASSES = newArrayList(Type)

	public static val TYPE_DEFINED_AFTER_REFERENCE = "typeDefiendAfterReference"

	@Check
	def emptyStringNamespace(AvroIDLFile file) {
		if (file.name != null) {
			if (file.name.isEmpty) {
				error("Namespace must not be empty", AvroIDLPackage.Literals.AVRO_IDL_FILE__NAME)
			}
		}
	}

	@Check
	def typeDefinedAfterReference(CustomTypeLink link) {
		val type = link.target
		if (type != null) {
			val idlFile = EcoreUtil2.getContainerOfType(type, AvroIDLFile)
			if (elementInSameFile(idlFile, link)) {
				val elements = idlFile.elements
				val linkContainerElement = EcoreUtil2.getContainerOfType(type, ProtocolElement)
				val ownContainerElement = EcoreUtil2.getContainerOfType(link, ProtocolElement)
				val linkElementIndex = elements.indexOf(linkContainerElement)
				val ownElementIndex = elements.indexOf(ownContainerElement)
				if (ownElementIndex < linkElementIndex) {
					error("Reference to type '" + link.target.name + "' is before type definition",
						AvroIDLPackage.Literals.CUSTOM_TYPE_LINK__TARGET, TYPE_DEFINED_AFTER_REFERENCE,
						ownElementIndex.toString, linkElementIndex.toString)
				}
			}

		}
	}

	def elementInSameFile(AvroIDLFile file, EObject eObject) {
		if (file != null) {
			val objectFile = EcoreUtil2.getContainerOfType(eObject, AvroIDLFile)
			return file == objectFile
		}
		return false
	}

	def getDuplicateMessage(EObject object, EStructuralFeature feature) {
		return "Duplicated " + object.eClass.superType.name + " '" + object.eGet(feature) + "'"
	}

	def isDuplicated(EObject object, EStructuralFeature nameFeature) {
		val name = object.eGet(nameFeature) as String;
		val internallyDuplicated = isInternallyDuplicated(object, nameFeature, name)
		if (!internallyDuplicated) {
			if (INCLUDE_EXTERNAL_DUPLICATE_NAME_CHECK_CLASSES.findFirst[it.isInstance(object)] != null) {
				return isExternallyDuplicated(object, nameFeature, name) // check for external import name duplications	
			}
		}
		return internallyDuplicated;
	}

	def isExternallyDuplicated(EObject object, EStructuralFeature nameFeature, String name) {
		val idlFile = object.getContainerOfType(AvroIDLFile);
		if (idlFile != null) {
			var Resource res
			var URI uri
			var AvroIDLFile IdlFile;

			for (import : idlFile.imports) {
				uri = URI.createURI(import.importURI)
				res = _rs.getResource(uri, true);
				if (object.isValidUri(uri)) {
					if (res != null && res.contents.size > 0) {
						IdlFile = res.contents.get(0) as AvroIDLFile
						if (IdlFile != null) {
							if (IdlFile.eAllContents.findFirst [
								it.eClass.superType == object.eClass.superType && it.eGet(nameFeature).equals(name)
							] != null) {
								return true;
							}
						}
					}
				}
			}
		}
		return false
	}

	def isInternallyDuplicated(EObject object, EStructuralFeature nameFeature, String name) {
		object.eContainer.eAllContents.findFirst [
			it.eClass.superType == object.eClass.superType && it.eGet(nameFeature).equals(name) && it != object
		] != null
	}

	public static def getSuperType(EClass eClass) {
		val superTypes = eClass.ESuperTypes
		if (superTypes.isEmpty) {
			return eClass
		} else {
			return superTypes.get(0)
		}
	}
}
